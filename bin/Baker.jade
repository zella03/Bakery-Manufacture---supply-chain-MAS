agent Baker uses ontology BakeryOntology
    
    property bread = Good(
    	"bread",
    	[
    		IngredientQuantity("flour", 2),
            IngredientQuantity("water", 2),
            IngredientQuantity("yeast", 1)
    	],
    	"PT20S" as duration,"PT10S" as duration,6
    )
    property bun = Good(
        "bun",
        [
            IngredientQuantity("flour", 2),
            IngredientQuantity("water", 2),
            IngredientQuantity("yeast", 1)
        ],
        "PT25S" as duration,"PT15S" as duration,8
    )
    property cookies = Good(
        "cookies",
        [
            IngredientQuantity("flour", 2),
            IngredientQuantity("water", 1),
            IngredientQuantity("eggs", 2),
            IngredientQuantity("sugar", 2)
        ],
        "PT15S" as duration,"PT20S" as duration,14
    )
    
    property cake = Good(
        "cake",
        [
            IngredientQuantity("flour", 4),
            IngredientQuantity("water", 2),
            IngredientQuantity("eggs", 3),
            IngredientQuantity("sugar", 2)
        ],
        "PT30S" as duration,"PT20S" as duration,1
    )
    property cupcakes = Good(
        "cupcakes",
        [
            IngredientQuantity("flour", 4),
            IngredientQuantity("sugar", 2),
            IngredientQuantity("eggs", 3)
        ],
        "PT10S" as duration,"PT15S" as duration,6
    )
    property recipeBook as list of Good
    
	property flour = IngredientQuantity("flour",20)
	property sugar = IngredientQuantity("sugar",20)
	property eggs = IngredientQuantity("eggs",20)
	property yeast = IngredientQuantity("yeast",20)
	property water = IngredientQuantity("water",20)
	property stock = [flour,sugar,eggs,yeast,water]
	
    property typeBaker as text
    property supervisorName as text
    property listOfCoworkers as list of text
    
    property ordersList as list of OrderStatus
    property currentlyAskingForOrder as boolean
    
	
	procedure changeToNormal do
	   typeBaker of this = "normal"
	   recipeBook = [bread, bun, cookies]
	   
	procedure chnageStatus with id as text,newStatus as text do #changing status of order
	   for i in ordersList do
	       if orderId of i = id do
	           status of i = newStatus
	           break
	
    on create with type as text, supervisor as text, coworker1 as text do
        typeBaker of this = type
        supervisorName of this = supervisor
        add coworker1 to listOfCoworkers
        #coworker2 as text
        #add coworker2 to listOfCoworkers
        
        log "BAKER created with arguments: " + typeBaker + ", " + supervisor
        
        #if (name of agent)@ = "Baker2" do
        activate DelayedWorkerReady after "PT2S" as duration
        #else do
        #    activate DelayedWorkerReady
        #log "Reported"

        # Assign recipeBook based on type
        if type = "normal" do
            recipeBook of this = [bread, bun, cookies]
        else do
            recipeBook of this= [cake, cupcakes]

        # Log recipes
        for good in recipeBook of this do
            log "Known recipe: " + name of good
        
        activate ManageOrders
        activate ListenCoworkers

one shot behavior DelayedWorkerReady for agent Baker uses ontology BakeryOntology
    on execute do
        #log "Sending WorkerReady: " + WorkerReady(aid of agent, typeBaker of agent)
        send message inform WorkerReady(aid of agent, typeBaker of agent) to supervisorName@
        log "WorkerReady message sent."
        
cyclic behaviour ManageOrders for agent Baker uses ontology BakeryOntology
    property endOfOrders as boolean
    
    on create do
        endOfOrders = false
        currentlyAskingForOrder = false
    on execute do
        count = 0
        if length of ordersList ≠ 0 do
            for i in ordersList do
                if status of i ≠ "baking" do
                    break
                else do 
                    count = count + 1 #we cannot ask for new order if we are preparing another one or when we lack of ingredients
            if count = length of ordersList and not endOfOrders and not currentlyAskingForOrder do #if everything is ONLY baking we can ask for another order to make
                log "BAKER: "+name of agent+" __ count of ord baking: "+count+" orderList: "+ ordersList+" end orders: "+ endOfOrders
                activate SendRequest
                currentlyAskingForOrder = true
    
    on message inform AgentsReported do
        currentlyAskingForOrder = true
        activate SendRequest
        activate WaitForNewOrder    
    
    on message inform OrderStatus(id,status) do
        log "BAKER: "+name of agent+" is finished."
        send message inform OrderStatus(id,status) to supervisorName@
        remove OrderStatus(id,status) from ordersList
        #log ordersList
      
    on message inform EndOfPrivateOrders do
        do changeToNormal
        log "BAKER: "+name of agent+" is changed into normal: "+typeBaker of agent
    
    on message inform EndOfOrders do # już się nie będzie pytał przynajmniej
        deactivate WaitForNewOrder
        endOfOrders = true
        
    ## here listening for finishing the work!!
    
    
    
one shot behavior SendRequest for agent Baker uses ontology BakeryOntology
    on execute do
        log "BAKER: "+name of agent + " sending request for an order from: " + supervisorName of agent
        send message request RequestOrder(aid of agent) to supervisorName@


cyclic behaviour WaitForNewOrder for agent Baker uses ontology BakeryOntology

    function checkIfKnow(good as text) as boolean do
        for item in recipeBook do 
            if name of item = good do
                return true
        return false
        
    on activate do
        log "BAKER: "+name of agent + " is waiting for new order from supervisor: " + supervisorName of agent
    
    on message request AssignOrder(agentId as aid, order as Order) do
        senderAgent = sender of message
        
        if checkIfKnow(good of order) do
            currentlyAskingForOrder = false
	        log "BAKER: "+name of agent +" received an order for: "+good of order +" from: " + name of senderAgent+" and knows the recipe"
	        status of order = "toPrepare"
	        orderWithStatus = OrderStatus(id of order,"toPrepare")
	        add orderWithStatus to ordersList
	        log "OrderList: "+ ordersList+" of BAKER: "+name of agent
	        activate PrepareOrder(order)
	    else do
	       log "BAKER: "+(name of agent)@+" received an order for: "+good of order +" but does not know the recipe!!"
        

cyclic behaviour ListenCoworkers for agent Baker uses ontology BakeryOntology
    property avaliable = true
    property providedIngredients as list of IngredientQuantity
    
    procedure clearProvidedIngredients do
        if length of providedIngredients ≠ 0 do
            for i in providedIngredients do
                remove i from providedIngredients
    
    function duringPreparation as boolean do
        for order in ordersList do
            if status of order = "preparing" do
                return true
        return false
     
    on message request AskForHelpColleague(agentId as aid, ingredients as list of IngredientQuantity) do
        senderAgent = sender of message
        log "BAKER: "+name of agent +" received a request for help from "+ name of senderAgent
        log "Needed ingredients: "+ingredients
        
        if not duringPreparation do
	        for ingredient in ingredients do
	            for item in stock do
	                if quantity of ingredient > quantity of item do
	                   log "Agent wants too much: "+ quantity of ingredient + " when i have "+ quantity of item
	                   send message inform IngredientAvaliable(aid, false) to senderAgent
	                   avaliable = false
	                   break
	            if not avaliable do
	                break
	    else do
	       log "BAKER: "+name of agent+"won't help with ingredients. PREPARING good"
           send message inform IngredientAvaliable(aid, false) to senderAgent
           avaliable = false
        
        if avaliable do
            send message inform IngredientAvaliable(aid, true) to senderAgent  
        
    on message request RequestIngredientsColleague(id as aid, listIngredientsNeeded as list of IngredientQuantity) do
        senderAgent = sender of message
        for ingredient in listIngredientsNeeded do
            for item in stock do
                if name of ingredient = name of item do
                   quantity of item = quantity of item - quantity of ingredient
                   add IngredientQuantity(name of ingredient, quantity of ingredient) to providedIngredients
        
        log "Items that are beeing send: "+providedIngredients +" by: "+name of agent
        log "My current stock after helping: "+stock
        
        send message request ProvideIngredients(providedIngredients) to senderAgent
        do clearProvidedIngredients # -> ################################################################check if correct

cyclic behaviour HandleIngredientsShortage for agent Baker uses ontology BakeryOntology
    property listIngredientsNeeded as list of IngredientQuantity 
    property order as Order
    property responds as list of IngredientAvaliable
    property noHelpFromCo = true
    
    on create with listIngredientsNeeded as list of IngredientQuantity,order as Order do
        listIngredientsNeeded of this = listIngredientsNeeded
        order of this = order
        
    on message inform IngredientAvaliable(id,avaliable) do
        senderAgent = sender of message
        respond = IngredientAvaliable(id,avaliable)
        if avaliable do
            log "Agent: "+ name of senderAgent + "has avaliable ingredients for :"+name of agent
        else do
            log "Agent: "+ name of senderAgent + "does NOT have avaliable ingredients for :"+name of agent
        
        add respond to responds
        if length of responds = length of listOfCoworkers do
            for i in responds do
		        if avaliable of i do
		            log "Asking agent: "+ name of id of i + "for his avaliable ingredients for :"+name of agent
		            send message request RequestIngredientsColleague(aid, listIngredientsNeeded) to id of i
		            noHelpFromCo = false
		            break
		    
		    #if noHelpFromCo do send request to supplier!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            
            # then deactivate
            
    on message request ProvideIngredients(handedIngredients) do 
        senderAgent = sender of message
        log "Just got ingredients from: "+senderAgent
        
        for ingredient in handedIngredients do
            for item in stock do
                if name of ingredient = name of item do
                   quantity of item = quantity of item + quantity of ingredient
        
        log "Fixed stock: "+stock
        activate PrepareOrder(order)
        deactivate this
        
        #if got deactivate 
   
   #on message from supplier with ingredient  or I could use provideIngredients 
                  


one shot behaviour PrepareOrder for agent Baker uses ontology BakeryOntology
    property order as Order
    property goodToPrepare as Good
    property ingredientsNeeded_lack as list of IngredientQuantity
    
    function canPrepareOrder(good as Good) as list of IngredientQuantity do
        for ingredientToProduce in ingredients of good do
            for item in stock do
                if name of item = name of ingredientToProduce do
                    if quantity of item < quantity of ingredientToProduce do
                        ingredientLack = IngredientQuantity(name of ingredientToProduce,(quantity of ingredientToProduce-quantity of item))
                        add ingredientLack to ingredientsNeeded_lack
        return ingredientsNeeded_lack
        
    function needRestoreStock as boolean do
        for item in stock do
            if quantity of item < 2 do
                return true
        return false
    
    procedure useOfIngredients with good as Good do
        for ingredientToProduce in ingredients of good do
            for item in stock do
                if name of item = name of ingredientToProduce do
                    quantity of item = quantity of item - quantity of ingredientToProduce
        
    procedure clearNeededIngredients do
        if length of ingredientsNeeded_lack ≠ 0 do
	        for i in ingredientsNeeded_lack do
	            remove i from ingredientsNeeded_lack
    
    
    on create with order as Order do
        order of this = order
        #log "Order: "+order
    
       
    on activate do
        for recipeOfGood in recipeBook do
            if name of recipeOfGood = good of order do
                goodToPrepare = recipeOfGood
                break
        ingredientsNeeded_lack = canPrepareOrder(goodToPrepare)
    on execute do
            
        if length of ingredientsNeeded_lack = 0 and status of order = "toPrepare" do
            do clearNeededIngredients
            do chnageStatus with id of order,"preparing"
            status of order = "preparing"
	        log "Agent: "+name of agent +" preparing: " + good of order
	        
	        do useOfIngredients with goodToPrepare
	        log "Currect state of stock: "+stock+" of agent "+ name of agent
	        if needRestoreStock do
	           log "send message to supplier"#######################################################################################
	        activate BakingOrderBehavior(order,bakingTime of goodToPrepare) after (preparationTime of goodToPrepare) as duration
	    else if length of ingredientsNeeded_lack != 0 and status of order = "toPrepare" do
	       #log "Not enough ingredients in stock"
	       #send message to supplier with ingredientsNeeded information#################################################################
	       for coworker in listOfCoworkers do
	           #checkedLackOfIngredients = true
	           send message request AskForHelpColleague(aid,ingredientsNeeded_lack)to coworker@
	           activate HandleIngredientsShortage(ingredientsNeeded_lack,order)      
        
        
cyclic behaviour BakingOrderBehavior for agent Baker uses ontology BakeryOntology
    property order as Order
    property time as duration
    property bakingTime as duration
    
    on create with order as Order, bakingTime as duration do
        order of this = order
        bakingTime of this = bakingTime
    
    on activate do
        do chnageStatus with id of order,"baking"
        status of order = "baking"
        log "Agent: "+name of agent+" started baking for: " + good of order
        time = now as duration
    
    on execute do
        if (now - time) as duration >= bakingTime as duration do
            log "Agent: "+name of agent+" finished baking: "+good of order+" of id: "+ id of order
            do chnageStatus with id of order,"finished"
            status of order = "finished"
            for orderWithStat in ordersList do
                if id of order = orderId of orderWithStat do
                    #log orderWithStat
                    send message inform orderWithStat to aid
                    deactivate this
                    break
                
        
        
                    


        
        
        
            
